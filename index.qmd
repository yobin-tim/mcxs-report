---
title: "Estimating the impact of monetary policy shocks on different housing indicators: A Bayesian SVAR Approach"
author: "Yobin Timilsena"

execute:
  echo: false
  
format: 
  html:
    toc-location: left
  
bibliography: references.bib
---

> **Abstract.**  This project uses a Bayesian SVAR approach to estimate the effects of domestic and foreign monetary policy shocks on housing prices and number of new houses in Australia. The identification relies on imposing exclusion-restrictions and the estimation process follows the @waggoner2003a algorithm using the Gibbs sampler. In the extended version, we estimate the hyperparameters of the priors of the model. We find that a positive domestic monetary policy shock reduces both the number of new houses and housing prices, while a positive foreign (US) monetary policy shock reduces the number of new houses but increases housing prices.
>
> **Keywords.** bsvars, impulse responses, quarto, R, housing price index, monetary policy shocks


# Introduction
Monetary policy is one of the key instruments used by central banks to influence the overall economic activity. In recent years, the housing market has become an increasingly important channel through which monetary policy affects the broader economy (@AK_2017), particularly in Australia where around 57% of household wealth is tied up in the housing market (@Sweeney_2023). That number is thrice as big as the size of the super market in Australia and as such, understanding the relationship between monetary policy shocks and the housing market is crucial for policy-makers, investors, and households alike.

In this study, we aim to estimate the impact of monetary policy shocks on various housing indicators using a Structural Vector Autoregressive (SVAR) modelling approach. SVAR models are a popular econometric tool for investigating the dynamic interactions between macroeconomic variables. By applying this approach, we seek to shed light on how changes in monetary policy impact different dimensions of the housing market.

# Research Question
The objective of this paper is to estimate and quantify the impact of monetary policy shocks on different indicators of the housing market such as housing prices, housing transactions/sales, and the total number of housing units within an economy. Understanding these effects is crucial in understanding how money affects a key factor of the real side of the economy. An extension to this paper could be determining whether monetary policy shocks create a trade-off between controlling housing prices and controlling economic activity.

# Data and their Properties
## Empirical Project Setup
This project website is being developed as a **Quarto** document and the empirical work in conducted using `R`. The necessary datasets are imported from the Reserve Bank of Australia (RBA) and the Australian Bureau of Statistics (ABS) websites using `readrba` and `readabs` respectively.

```{r load packages, include=FALSE, warning=FALSE, eval=TRUE}
rm(list = ls())
pkgs <- c('ggplot2', 'tidyr', 'dplyr', 'lubridate', 'readrba', 'readabs', 'tidyverse', "xts", "plotly", "rmarkdown","quantmod", "zoo", "HDInterval", "plot3D", "mvtnorm")
# install.packages(pkgs)
lapply(pkgs, library, character.only=TRUE)
```


## Choice of variables
I use the following variables to answer this question. I discuss the relevance of each variable.

- $\log(M1)$: represents the log of the money supply M1. Both conventional and unconventional monetary policy shocks can change the stock of money supply and its size affects real variables of the economy.

- $\Delta CPI$: represents the year-on-year change in the Consumer Price Index (CPI). It is a measure of inflation in an economy and is affected by monetary policy shocks.

- $\log(c)$: represents the log of consumption of the economy. Monetary policy shocks can alter people's consumption-savings behaviour.

- $\log(GDP)$: represents the log of the Gross Domestic Product (GDP). Including this along with the consumption helps differentiate the effect on the non-consumption aspect of the economy.

- $loanrate$: represents the weighted average interest rates on owner-occupied home loans. 

- $AUCR$: represents the Australian Cash Rate Target. This is the major monetary policy instrument available to the RBA.

- $USFFR$: represents the Federal Funds Rate Maximum Target Rate. Monetary policy adopted in the US tend to ripple into other economies so this is a variable of interest. Another extension to this variable would be to include the Target rates of Australia's largest trading partners.

- $nhouses$: represents the number of new private dwellings (houses) approved for construction in Australia. Impact on housing prices might be dampened by the supply elasticity of housing captured by this variable.

- $PPI$: represents the Property Price Index in Australia. The index is normalized with respect to the property prices in 2011-2012.


```{r download relevant variables, eval=FALSE, warning=FALSE}

# M1 Money Supply; quarterly; billions; log
m1.raw        <- read_rba_seriesid("DMAM1N")
m1.qtr        <- to.quarterly(xts(m1.raw$value, m1.raw$date), OHLC = F)
m1.qtr[,]     <- log(m1.qtr[,])

# Change in CPI; quarterly; pct change yoy
# Use cpi.raw <- read_rba_seriesid("GCPIAG") to get actual index value.
cpi.raw       <- read_rba_seriesid("GCPIAGYP")
cpi.qtr       <- to.quarterly(xts(cpi.raw$value, cpi.raw$date), OHLC = F)

# Consumption share of GDP; quarterly; millions -> billions; log
consumption.raw    <- read_rba_seriesid("GGDPECCVPSH")
consumption.qtr    <- to.quarterly(xts(consumption.raw$value, consumption.raw$date), OHLC = F)
consumption.qtr[,] <- log(consumption.qtr[,]/1000)

# Nominal GDP; quarterly; millions -> billions; log
gdp.raw       <- read_rba_seriesid("GGDPECCPGDP")
gdp.qtr       <- to.quarterly(xts(gdp.raw$value, gdp.raw$date), OHLC = F)
gdp.qtr[,]    <- log(gdp.qtr[,]/1000)

# Owner-occupied variable home loan rates; monthly; 
homeloan.raw  <- read_rba_seriesid("FILRHLBVS")
homeloan.qtr  <- to.quarterly(xts(homeloan.raw$value, homeloan.raw$date), OHLC = F)


# AUS CR Target Rate; monthly; starts from 1990
cashrate.raw  <- read_rba_seriesid("FOOIRATCR")
cashrate.qtr  <- to.quarterly(xts(cashrate.raw$value, cashrate.raw$date), OHLC = F)

# US FFR Max Target Rate; monthly -> quarterly,
usffr.raw     <- read_rba_seriesid("FOOIRUSFFTRMX")
usffr.qtr     <- to.quarterly(xts(usffr.raw$value, usffr.raw$date), OHLC = F)

# real money balances


# quantity of dwelling units, houses; monthly; jul 1983
nhomes.raw    <- read_abs_series("A418433F")
nhomes.qtr    <- to.quarterly(xts(nhomes.raw$value, nhomes.raw$date), OHLC = F)
nhomes.qtr[,] <- log(nhomes.qtr[,]/1000)

# Residential property price index; quarterly; sep 2003
homeprice.raw <- read_abs_series("A83728455L")
homeprice.qtr <- to.quarterly(xts(homeprice.raw$value, homeprice.raw$date), OHLC = F)
homeprice.qtr[,] <- log(homeprice.qtr[,])
```


```{r  truncating data; creating a dataframe, eval=FALSE, warning=FALSE}
df <- as.data.frame(na.omit(cbind(m1.qtr,cashrate.qtr,usffr.qtr)))
df                                      <- head(df,-1) # remove the last obs 
colnames(df)                            <- c("M1 Money Supply (logs)","RBA Target Cash Rate","US FFR Max Target Rate")
df["% Change in CPI, yoy"]              <- as.numeric(cpi.qtr[268:length(cpi.qtr)])                 
df["Aggregate Consumption (log)"]       <- as.numeric(tail(consumption.qtr,nrow(df)))
df["Nominal GDP (log)"]                 <- as.numeric(tail(gdp.qtr,nrow(df)))
df["Owner-occupied home loan rates"]    <- as.numeric(tail(homeloan.qtr,nrow(df)+1))[-133]
df["Quantity of new homes (log)"]                 <- as.numeric(tail(nhomes.qtr,nrow(df)+1))[-133]
df                                      <- head(df,-4) # drop the last 4 obs 
df["House Price Index (log)"]                 <- NA 
df[55:128,"House Price Index (log)"]          <- as.numeric(homeprice.qtr)
df                                      <- na.omit(df)
df                                      <- df %>% select("US FFR Max Target Rate", "Nominal GDP (log)", "Aggregate Consumption (log)",
                                                         "% Change in CPI, yoy", 
                                                         "RBA Target Cash Rate","M1 Money Supply (logs)", 
                                                         "Owner-occupied home loan rates",  "Quantity of new homes (log)",
                                                         "House Price Index (log)",)
                                            
```

```{r  Step 0 - Load saved data, eval=TRUE, include=FALSE, warning=FALSE}
  load(file = "ProjectData.RData") # load saved empirical data if needed
```

```{r show the first few observations from the dataset, eval=TRUE, warning=FALSE}
head_df <- head(df)
rmarkdown::paged_table(head_df)
```

```{r save loaded data, eval=FALSE, warning=FALSE}
save.image(file="ProjectData.RData")
```


## Data Properties
The variables discussed above are illustrated in the figure below. Note that the logged variables trend upwards because they are expressed in their levels, while variables expressed in percentage change terms do not exhibit this behaviour.


The dataset will be used in the sample consists quarterly data from 2003 Q3 to 2021 Q4, including 74 observations, plots of truncated dataset is shown as: 


```{r plot the data, echo=TRUE}
var_names <- colnames(df)
date_range <- as.yearqtr(rownames(df), format = "%Y Q%q")
par(mfrow = c(3,3), mar=c(2,2,2,2))
for (j in 1:ncol(df)){
  plot(x = date_range, y = df[,j],,type='l',
       main = paste(var_names[j]), ylab = "", xlab = "",
       lwd = 2.5,
       ylim = c(min(df[,j]),max(df[,j])))
}

```

```{r  save pdf of data plots, eval=FALSE}
pdf(file = "dataplot.pdf", width = 16, height = 9)
var_names <- colnames(df)
date_range <- as.yearqtr(rownames(df), format = "%Y Q%q")
par(mfrow = c(3,3), mar=c(2,2,2,2))
for (j in 1:ncol(df)){
  plot(x = date_range, y = df[,j],,type='l',
       main = paste(var_names[j]), ylab = "", xlab = "",
       lwd = 2.5,
       ylim = c(min(df[,j]),max(df[,j])))
}
dev.off()
```



### ADF Tests
Next, I perform and display ADF test results on the variables. I report, for each variable, the difference level at which the ADF tests rejects the null that the series is non-stationary. 

```{r  perform adf tests on the data, warning= FALSE, echo=TRUE}

perform_adf_tests <- function(df) {
  # Create an empty dataframe to store the results
  results <- data.frame(Variable = character(), TestType = character(), 
                        TestStatistic = numeric(), PValue = numeric(), 
                        stringsAsFactors = FALSE)

  # Iterate over each column in the dataframe
  for (col in colnames(df)) {
    # Remove NA values from the column
    column_data <- na.omit(df[[col]])

    # Perform ADF test for levels
    adf_levels <- tseries::adf.test(na.omit(column_data), k = 4)

    # Check if p-value is less than or equal to 0.05
    if (adf_levels$p.value <= 0.05) {
      results <- bind_rows(results,
        data.frame(Variable = col, TestType = "Levels", 
                   TestStatistic = adf_levels$statistic,
                   PValue = adf_levels$p.value)
      )
    } else {
      # Perform ADF test for first difference
      adf_diff1 <- tseries::adf.test(na.omit(diff(column_data)), k = 4)
      
      # Check if p-value is less than 0.05
      if (adf_diff1$p.value < 0.05) {
        results <- bind_rows(results,
          data.frame(Variable = col, TestType = "First Difference", 
                     TestStatistic = adf_diff1$statistic,
                     PValue = adf_diff1$p.value)
        )
      } else {
        # Perform ADF test for second difference
        adf_diff2 <- tseries::adf.test(na.omit(diff(column_data, differences = 2)), k = 4)
        
        results <- bind_rows(results,
            data.frame(Variable = col, TestType = "Second Difference", 
                       TestStatistic = adf_diff2$statistic,
                       PValue = adf_diff2$p.value)
          )
      }
    }
  }


  # Return the results dataframe
  return(results)
}

adf_test_results <- perform_adf_tests(df)
rmarkdown::paged_table(adf_test_results)

```
```{r save the adf test results as a latex table, eval=FALSE}
adf_table = xtable::xtable(adf_test_results)
print(adf_table, file = "adf_table.tex", include.rownames = FALSE)
```


### ACF Plots
```{r  ACF, include=TRUE}
#| label: ACF-Plots
#| fig-cap: "ACF Plots for our data"
par(mfrow = c(3,3), mar=c(2,2,2,2))
for (j in 1:ncol(df)){
  acf(df[,j], xlab="")
  title(main=var_names[j])
}

```

```{r save the acf plots as pdf, eval=FALSE}
pdf(file = "acf.pdf", width = 12, height = 8)
par(mfrow = c(3,3), mar=c(2,2,2,2))
for (j in 1:ncol(df)){
  acf(df[,j], xlab="")
  title(main=var_names[j])
}
dev.off()
```


### PACF Plots
```{r  PACF, include=TRUE}
#| label: PACF-Plots
#| fig-cap-location: top
#| fig-cap: "PACF Plots for our data"
par(mfrow = c(3,3), mar=c(2,2,2,2))
for (j in 1:ncol(df)){
  pacf(df[,j], xlab="")
  title(main=var_names[j])
}
```

```{r  save pacf plots in a pdf document, eval=FALSE}
pdf(file = "pacf.pdf", width = 12, height = 8)

par(mfrow = c(3,3), mar=c(2,2,2,2))
for (j in 1:ncol(df)){
  pacf(df[,j], xlab="")
  title(main=var_names[j])
}
```


# Model and Hypothesis
I employ a structural VAR model to assess the impact of monetary policy shocks on different housing indicators. The SVAR model with $p$ lags can be written as
$$
\begin{align}
&B_0Y_t = B_0 + B_1 Y_{t-1} + \dots + B_p Y_{t-p} + U_t\\
&U_{t}| Y_{t-1} \dots Y_{t-p} \sim _{iid} ( 0_N, I_N)
\end{align}
$$ 
where
$$
Y_t =
            \begin{pmatrix}
                USFFR_t\\
                \log(GDP_t)\\
                \log(c_t)\\
                \Delta CPI_t\\
                AUCR_t\\
                \log(q_{\text{new homes}_t})\\
                \log(HPI_t)\\
                i_{\text{home loan}_t}\\
                \log(M1_t)
            \end{pmatrix}
$$

$B_0$ is a **structural matrix ** that captures the contemporaneous relationship between the variables in $Y_t$. $U_t$ represents conditionally independent **structural shocks**.

In many cases, the structural model can be estimated utilizing the information from its corresponding RF model
$$
\begin{align}
&Y_t = A_0 + A_1 Y_{t-1} + \dots + A_p Y_{t-p} + E_t\\
&E_{t}| Y_{t-1} \dots Y_{t-p} \sim _{iid} ( 0_N, \Sigma)
\end{align}
$$ 
where $A_i = B_0^{-1}B_i$ and $B_0^{-1}I_N  (B_0^{-1})'$.


The identification in the SVAR model can be achieved either by using some exclusion restrictions, sign restrictions, instrumental variables, or prior distribution. The next section will talk about the exact composition of the structural matrix and the conditions for identification. 

## Identification
I plan to use exclusion-restrictions to identify the structural matrix $B_0$. In particular, I will impose a lower-triangular restriction on $B_0$ and employ the solution concept in @waggoner2003b who use a normalization rule as an optimal solution to the local identification problem. I will then employ the Gibbs sampler for a SVAR model with exclusion restrictions as in @waggoner2003a to obtain draws for $B_0$ and $B_+$.

$$ B_0 Y = B_+ X + U, \qquad \qquad U|X \sim \mathcal{MN}_{N \times T}(\textbf{0}_{N \times T}, I_T, I_N) $$
where 

$B_0$ is a $N \times N$ contemporaneous effects matrix.

$Y = [y_1, \dots, y_T]$ is a $N \times T$ matrix of observations.

$B_+ = [B_d, B_1, \dots, B_p]$ is a $N \times K$ matrix of autoregressive parameters, where $K = Np + d$  ($d$ is the number of deterministic terms; $p$ is the number of lags).

$X = [x_1, \dots, x_T]$ is a $K \times T$ matrix of lagged observations where each $x_t = (1, y_{t-1}, \dots, y_{t-p})'$.

$U = [u_1, \dots, u_T]$ is a $N \times T$ matrix of structural shocks.

For convenience of coding and inference purposes, we consider a row-wise equation form as follows:
$$ B_{0[n.\cdot]} Y = B_{+n} X + U_n, \qquad \qquad U_n|X \sim \mathcal{N}(\mathbf{0}_T, I_T) $$

If $r_n$ denotes the number of elements in the $n^{th}$ row of $B_0$ that stay unrestricted, then we can further decompose $B_{0[n.\cdot]}$ into $b_n$ and $V_n$. 

$b_n$ is a $1 \times r_n$ vector of unrestricted elements in the $n^{th}$ row of $B_0$.

$V_n$ is a $r_n \times N$ matrix which places elements of $b_n$ in the appropriate positions to impose the restrictions on $B_0$. 

Then, the row-wise equation form can be written as follows:
$$ b_n V_n Y = B_{+n} X + U_n, \qquad \qquad U_n|X \sim \mathcal{N}(\mathbf{0}_T, I_T) $$
Following @waggoner2003a and @arias2018a, we define that $(B_+, B_0)$ follow jointly a Normal-Generalised Normal (NGN) distribution denoted as 
$$ p(B_+, B_0) \sim \mathcal{NGN}(B, \Omega, S, \nu)$$ 

if $B_{+n}$ follows a K-variate normal distribution given $b_n$ 
$$ p(B_{+n}|b_n) = \mathcal{N}_k(b_nV_nB, \Omega) $$  with kernel $$ p(B_{+n}|b_n) \propto \exp \left\{  -\frac{1}{2} \left( B_{+n} - b_nV_nB \right) \Omega^{-1}  \left( B_{+n} - b_nV_nB \right)' \right\} $$


for $n = 1, \dots, N$ and $b_1, \dots, b_N$ jointly have a distribution whose kernel is specified by 
$$ p(b_1, \dots, b_N) \propto | \det(B_0) |^{\nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n S^{-1} V_n' b_n'  \right\} $$

The joint-distribution of $(B_+, B_0)$ can then be written as
$$ p(B_0, B_+) = \left( \prod_{n=1}^N p(B_{+n}|b_n)\right) p(b_1, \dots, b_N) $$

This classification of the joint-distribution allows us to obtain natural-conjugate prior and corresponding posterior distributions.

Moreover, the following function imposes a lower-triangular restriction on $B_0$ and creates a list containing a matrix of $b_n$ and corresponding $V_n$ row vectors. 
```{r  Impose the type of exclusion restriction, echo=TRUE}

ltexclusion = function(usedata){
  BM.V        = vector("list",usedata$N)
for (n in 1:usedata$N){
  BM.V[[n]]   = cbind(diag(n),matrix(0,n,usedata$N-n))
}

B0.initial    = matrix(0,usedata$N,usedata$N)
for (n in 1:usedata$N){
  unrestricted               = apply(BM.V[[n]],2,sum)==1
  B0.initial[n,unrestricted] = rnorm(sum(unrestricted))
}
B0Vlist       = list(B0.initial = B0.initial, V = BM.V)
}
```


## Basic Model
### Prior distribution
Given this parameterisation, we can write down the kernel of the **prior** given hyperparameters $(\underline B, \underline \Omega, \underline S, \underline \nu)$ as follows:
$$ 
| \det(B_0) |^{\underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n \underline S^{-1} V_n' b_n'  \right\}  \exp \left\{  -\frac{1}{2}  \sum_{n=1}^N  \left( B_{+n} - b_nV_n \underline B \right) \underline \Omega^{-1}  \left( B_{+n} - b_nV_n \underline B \right)' \right\}  
$$

This prior distribution has two key advantages. Firstly, it leads to a full-conditional posterior distributions that allow efficient sampling. This allows us to estimate the structural parameters of the SVAR model.

Secondly, it belongs to a class of reference prior distributions that are invariant to the pre-multiplication of the parameter matrices by a rotation matrix up to which the system is identified (see @rr2010). This allows us to conduct a proper Bayesian treatment of this model given the identification above.


```{r  include code from L16 codes.R}
  source("L16 codes.R")
```

#### Calibration of the prior
- $\underline \nu = N$ is a commonly chosen value as it implies that the generalised-normal part is equivalent to a $r_n$-variate normal with the mean equal to a vector of zeros and the covariance matrix equal to $\underline S$.
- $\underline S = \kappa_3 I_N$ implies that the covariances across the rows of $B_0$ is zero, and the variance of each row is homoskedastic (constant). $\kappa_3$ can be interpreted as a contemporaneous effects shrinkage and is set to 10.
- $\underline B = [0_{N \times 1} \; \kappa_4 I_N \; 0_{N \times (p-1)N}]$ implies an AR1 process for the structural VAR at the prior mean. In this calibration, $\kappa_4 = 1$, the AR1 process is a random walk process.
- $\underline \Omega = \begin{pmatrix} \kappa_2 & 0\\ 0 & \kappa_1 I_{Np} \end{pmatrix}$ is the prior covariance matrix. It is taken to be a diagonal matrix with the diagonal elements set as the Litterman prior. $\kappa_2$ represents the constant term shrinkage and is set to 10. $\kappa_1$ represents the autoregressive slope shrinkage and is set to 0.1.

We also calibrate the number of draws $S = 5000$ for any sampling, while the $S.burnin = 100$ represents the number of draws that are sampled first and then discarded.

The following `R` code creates a list of model parameters with the calibration as above. 
```{r  set prior parameters, echo=TRUE}

# set the priors

parameters = list(
  kappa1    = .1,       # autoregressive slope shrinkage
  kappa2    = 10,       # constant term shrinkage
  kappa3    = 10,       # contemporaneous effects shrinkage
  kappa4    = 1,        # VAR prior persistence
  S         = 5000,     # number of sample draws
  S.burnin  = 100,      # number of initial draws that are burned-in
  h         = 16        # forecast horizon
)
```

The following `R` function takes as argument data and model parameters to compute parameters of the prior distribution and store it as a list.
```{r  define the prior function, echo=TRUE}
# A function that computes and stores all the prior distribution components given a parameter list input
prior     = function(parameters, usedata){
  priors  = list(
  B       = cbind(rep(0,usedata$N), parameters$kappa4*diag(usedata$N), matrix(0, usedata$N, (usedata$p-1)*usedata$N)), # random walk prior
  Omega   = diag(c(parameters$kappa2,parameters$kappa1*((1:usedata$p)^(-2))%x%rep(1,usedata$N))),
  # Omega = diag(c(parameters$kappa2,parameters$kappa1*rep(1,usedata$N*usedata$p))),
  S       = parameters$kappa3*diag(usedata$N),
  nu      = usedata$N
  )
}
```



### Likelihood Function
The conditional normality of the error term allows us to write the kernel of the likelihood function and show that it can be expressed as a NGN distribution.
$$
\begin{align*}
    &L(B_+, B_0|Y,X) \propto | \det(B_0^{-1}B_0^{-1'})|^{-\frac{T}{2}} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N \left(b_n V_n Y - B_{+n} X \right) \left( b_n V_n Y - B_{+n} X  \right)' \right\}\\
    & = | \det(B_0)|^{T} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N \left( b_n V_n Y Y' V_n' b_n' - 2 b_n V_n Y X' B_{+n}' + B_{+n} X X' B_{+n}' \right) \right\}\\
    & = | \det(B_0)|^{T} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N \left( b_n V_n Y Y' V_n' b_n' + B_{+n} X X' B_{+n}' - 2 b_n V_n Y X' (XX')^{-1} (XX') B_{+n}' \right. \right. \\
    & \left. \left. + b_n V_n Y X' (XX')^{-1} (XX') (XX')^{-1} XY'V_n'b_n' - b_n V_n Y X' (XX')^{-1} (XX') (XX')^{-1} XY'V_n'b_n' \right) \right\}\\
    & = | \det(B_0)|^{T} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N \left( b_n V_n [ YY' - YX'(XX')^{-1}XY'] V_n' b_n'  + B_{+n} X X' B_{+n}' \right. \right. \\
    & \left. \left. - 2 b_n V_n Y X' (XX')^{-1} (XX') B_{+n}' + b_n V_n Y X' (XX')^{-1} XY' V_n' b_n' \right) \right\}\\
    & \text{}\\
    & \text{Let $\hat A = YX' (XX')^{-1} $, then we can simplify}\\
    & \text{}\\
    & =  | \det(B_0)|^{T} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N \left( b_n V_n [ YY' - \hat A XY'] V_n' b_n'  + B_{+n} X X' B_{+n}' - 2 b_n V_n \hat A (XX') B_{+n}' \right. \right.\\ & \left. \left. + b_n V_n \hat A XY' V_n' b_n' \right) \right\}\\
    & =  | \det(B_0)|^{T} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N \left( b_n V_n [ YY' - \hat A XY'] V_n' b_n'  + (B_{+n} - b_n V_n \hat A) X X' (B_{+n} - b_n V_n \hat A)' \right) \right\}\\
    & =  | \det(B_0)|^{T} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n [ YY' - \hat A XY'] V_n' b_n' \right\} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N (B_{+n} - b_n V_n \hat A) X X' (B_{+n} - b_n V_n \hat A)' \right\}
\end{align*}
$$

Comparing this with the general NGN kernel, we can write that

$$ 
L(B_+, B_0|Y, X) = \mathcal{NGN}(\tilde B, \tilde \Omega, \tilde S, \tilde \nu) 
$$
where

$$ 
\tilde B = \hat A, \quad \tilde \Omega = (XX')^{-1}, \quad \tilde S = ( YY' - \hat A XY')^{-1}, \quad \tilde \nu = T + N. 
$$
Hence, we have shown that the likelihood function follows a NGN distribution.

### Posterior Distribution
The prior and the likelihood can be used to obtain the posterior as follows:

$$
\begin{align*}
    & p(B_+, B_0|Y, X)  \propto L(B_+, B_0|Y, X) p(B_0, B_+)\\
    & = | \det(B_0)|^{T} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N \left(b_n V_n Y - B_{+n} X \right) \left( b_n V_n Y - B_{+n} X  \right)' \right\}\\
    & \times | \det(B_0) |^{\underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n \underline S^{-1} V_n' b_n'  \right\}  \exp \left\{  -\frac{1}{2}  \sum_{n=1}^N  \left( B_{+n} - b_nV_n \underline B \right) \underline \Omega^{-1}  \left( B_{+n} - b_nV_n \underline B \right)' \right\} \\
    & =  | \det(B_0) |^{T + \underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N \left(b_n V_n Y Y' V_n' b_n' - 2 b_n V_n Y X' B_{+n}' + B_{+n} X X' B_{+n}' \right) \right.\\
    & \left. + b_n V_n \underline S^{-1} V_n' b_n' + B_{+n} \underline \Omega^{-1} B_{+n}' - 2 b_n V_n \underline B \underline \Omega^{-1} B_{+n}' + b_n V_n \underline B \underline \Omega^{-1} \underline B' V_n' b_n' \right\}\\
    & =  | \det(B_0) |^{T + \underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n [ YY' + \underline S^{-1} + \underline B \underline \Omega^{-1} \underline B'] V_n' b_n' - 2 b_n V_n [ YX' + \underline B \underline \Omega^{-1} ] B_{+n}' \right.\\
    & \left. + B_{+n} [ XX' + \underline \Omega^{-1} ] B_{+n}' \right\}\\ & \text{}\\
    & \text{ Let $ \bar \Omega = (XX' + \underline \Omega^{-1})^{-1} $, then we can write}\\ & \text{}\\
    & =  | \det(B_0) |^{T + \underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n [ YY' + \underline S^{-1} + \underline B \underline \Omega^{-1} \underline B'] V_n' b_n' - 2 b_n V_n [ YX' + \underline B \underline \Omega^{-1} ] \bar \Omega \bar \Omega^{-1} B_{+n}' \right.\\
    & \left. + B_{+n} \bar \Omega^{-1} B_{+n}' \right\}\\
    & \text{}\\
    & \text{ Let $ \bar B = (YX' + \underline B \underline \Omega^{-1}) \bar \Omega $, then we can write}\\ & \text{}\\
    & =  | \det(B_0) |^{T + \underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n [ YY' + \underline S^{-1} + \underline B \underline \Omega^{-1} \underline B' - \bar B \bar \Omega^{-1} \bar B' ] V_n' b_n'  \right.\\
    & \left.  + b_n V_n  \bar B \bar \Omega^{-1} \bar B' V_n' b_n' - 2 b_n V_n \bar B \bar \Omega^{-1} B_{+n}' + B_{+n} \bar \Omega^{-1} B_{+n}' \right\}\\
    & \text{}\\
    & \text{ Define $ \bar S = (YY' + \underline S^{-1} + \underline B \underline \Omega^{-1} \underline B' - \bar B \bar \Omega^{-1} \bar B')^{-1} $, then we can write}\\ & \text{}\\
    & =  | \det(B_0) |^{T + \underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n \bar S^{-1} V_n' b_n'  + (B_{+n} - b_n V_n \bar B) \bar \Omega^{-1} (B_{+n} - b_n V_n \bar B)' \right\}\\
    &  = | \det(B_0) |^{T + \underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n \bar S^{-1} V_n' b_n'  \right\} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N (B_{+n} - b_n V_n \bar B) \bar \Omega^{-1} (B_{+n} - b_n V_n \bar B)' \right\}
\end{align*}
$$
Thus, $$ p(B_+, B_0|Y,X) \sim \mathcal{NGN}(\bar B, \bar \Omega, \bar S, \bar \nu) $$
where the first three parameters are defined above and $\bar \nu = T + \underline \nu$.

The following `R` function uses the prior and information contained in data to compute and store (as a list) the set of posterior parameters for our model. 
```{r  define the posterior function, echo=TRUE}
posterior     = function(priors, usedata){
  Omega.inv   = solve(priors$Omega)
  Omega.post.inv = usedata$X%*%t(usedata$X) + Omega.inv
  Omega.post  = solve( Omega.post.inv )
  B.post      = (usedata$Y%*%t(usedata$X) + priors$B%*%Omega.inv) %*% Omega.post
  S.post      = solve(usedata$Y%*%t(usedata$Y) + solve(priors$S) + priors$B%*%Omega.inv%*%t(priors$B) - B.post%*%Omega.post.inv%*%t(B.post) )
  nu.post     = ncol(usedata$Y) + priors$nu

  posteriors  = list(
  B           = B.post,
  Omega       = Omega.post,
  S           = S.post,
  nu          = nu.post
)
}

```

### (Gibbs) Sampling 
The sampling algorithm follows the derivation by @waggoner2003a. The algorithm first samples $b_1, \dots, b_n$ independent of $B_+$ in a serial, iterative fashion. Then, the sampled $b_1, \dots, b_n$ are normalised. Using the normalised $b_1, \dots, b_n$ and data, $B_{+n}$ can be drawn independently. 

#### Sample $b_1, \dots, b_n$ iteratively
Recall that the marginal posterior distribution of $b_1, \dots, b_n$ is proportional to
$$
| \det(B_0) |^{\underline \nu - N} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n \underline S^{-1} V_n' b_n'  \right\}
$$
The Gibbs sampler draws from the full conditional posterior distribution of vector $b_n$ given data as well as parameters from other rows of contemporaneous effects matrix, that is, $b_1, \dots,  b_{n-1}, b_{n+1}, \dots, b_{N}$. The full conditional posterior is denoted as
$$
p(b_n|Y, X, b_1, \dots,  b_{n-1}, b_{n+1}, \dots, b_{N})
$$
To sample from the full conditional posterior $p(b_n^{(s)}|Y, X, b_1^{(s)}, \dots,  b_{n-1}^{(s)}, b_{n+1}^{(s-1)}, \dots, b_{N}^{(s-1)})$ at each iteration $s$ and at each row $n$, the following steps are undertaken:

**Step 1:** define and compute the following values

- $U_n = chol \left( \bar \nu (V_n \bar S^{-1}V_n')^{-1}  \right)$ -- an $r_n \times r_n$ upper-triangular matrix;

- $w = B_{0[-n.\cdot]\perp}^{(s)}$ -- a $1 \times N$ matrix;

- $w_1 = wV_n'U-n' \cdot \left( w V_n'U_n'U_n V_n w' \right)^{-\frac{1}{2}}$ -- a $1 \times r_n$ vector;

- $W_n = [w_1' \quad w_{1 \perp}']'$ -- a $r_n \times r_n$ matrix.

**Step 2:** draw the elements of a $1 \times r_n$ vector $\alpha_n$ defined as follows:
- draw the first element by drawing $u \sim \mathcal{N}(\textbf{0}_{\nu+1}, \bar \nu^{-1}I_{\nu+1}) and setting 
$$
\alpha_{n[\cdot.1]} = 
\begin{cases}
\sqrt{u'u} & \text{ with probability } 0.5\\
-\sqrt{u'u} & \text{ with probability } 0.5
\end{cases}
$$
- draw the remaining $r_n-1$ element of $\alpha_n$ from $\mathcal{N}(\textbf{0}_{r_n-1}, \bar \nu^{-1} I_{r_n-1})$.

**Step3:** compute the draw from the full-conditional posterior distribution of $b_n$ by 
$$
b_n^{(s)} = \alpha_n W_n U_n
$$

Note that $X\perp$ refers to the orthogonal-complement matrix of $X$. And, $B_{0[-n.\cdot]}$ refers to the matrix $B_{0}$ without its n$^{th}$ row.

#### Normalise $b_1, \dots, b_n$
@waggoner2003b provide a normalising rule that preserves the shape of the likelihood function. These normalised draws from the normal-generalised-normal posterior distribution are free of the local identification problem and hence the estimates post-normalisation are meaningful and appropriate for statistical inference.

**Step 1:** normalise with respect to one mode $\hat B_0$ of the posterior distribution.
Let $\hat B_0$ be defined as
$$
  \hat B_0 = chol((\bar\nu-N)*\bar S)'
$$

**Step 2:** define scaling matrices $D_i$ for $i=1,\cdot,2^N$.

These $N \times N$ matrices $D_i$ are diagonal matrices with diagonal elements equal to -1 or 1. Thus, $2^N$ set of $D_i$ matrices cover all possible combinations of -1 and 1 on the diagonal.

**Step 3:** compute the distance between $D_i B_0^{(s)}$ and $\hat B_0$.

$$
 d \left( \left[ \left( D_i B_0^{(s)} \right)^{-1'} - \hat B_0^{-1'}   \right] | (\hat B_0' \hat B_0)^{-1}   \right) = \sum_{n=1}^N \left[ \left( D_i B_0^{(s)} \right)^{-1'} - \hat B_0^{-1'}   \right]_{[n. \cdot]} (\hat B_0' \hat B_0)^{-1}  \left[ \left( D_i B_0^{(s)} \right)^{-1'} - \hat B_0^{-1'}   \right]_{[n. \cdot]}'
$$

The choice of $D_i$ that minimises this distance is used to create the normalised draw $D_{i*(s)}B_0^{(s)}$ after applying it to all of the $S$ draws.


#### Sample $B_{+n}$ independently
For each draw of $b_n^{(s)}$, a corresponding draw of $B_{+n}^{(s)}$ is directly sampled from the normal distribution below:
$$
B_{+n}^{(s)} \sim \mathcal{N}(b_n^{(s)}V_n \bar B_n, \bar Omega)
$$


The `posteriorSimuations` function below takes model parameters, the posterior parameters, the exclusion restriction and the number of variables as given to sample draws using the Gibbs sampler. The functions `rgn`, `normalize.Gibbs.output.parallel` and `rnorm.ngn` are obtained from [Tomasz WoÅºniak](https://github.com/donotdespair)'s lecture notes. These functions are provided in the [Appendix](#appendix).
```{r  function to sample B0 and then B+ using wz2003, echo=TRUE}
posteriorSimulations  = function(parameters, posteriors, B0Vlist, N){
  t0                  = proc.time()
  B0.posterior        = rgn(n=parameters$S.burnin, S.inv=solve(posteriors$S), nu=posteriors$nu, V=B0Vlist$V, B0.initial=B0Vlist$B0.initial)
  t1                  = proc.time()
  (t1-t0)/60
  
  # sampling B0 from the posterior distribution using Gibbs
  t0                  = proc.time()
  B0.posterior        = rgn(n=parameters$S, S.inv=solve(posteriors$S), nu=posteriors$nu, V=B0Vlist$V, B0.initial=B0.posterior[,,parameters$S.burnin])
  t1                  = proc.time()
  (t1-t0)/60
  
  # normalisation
  B0.hat              = t(chol((posteriors$nu-N)*posteriors$S))                   # normalisation using this B0.hat should work
  BM.B0.posterior     = normalize.Gibbs.output.parallel(B0.posterior,B0.hat=B0.hat)
  t2                  = proc.time()
  (t2-t1)/60
  
  # sample B+ from the normal conditional posterior
  t2                  = proc.time()
  BM.Bp.posterior     = rnorm.ngn(BM.B0.posterior, B=posteriors$B,Omega=posteriors$Omega)
  t3                  = proc.time()
  (t3-t2)/60
  
  list(B0.posterior   = BM.B0.posterior, Bp.posterior = BM.Bp.posterior)
}
```



The `posteriorMeans` function below computes the sample average of the $B_0$ and $B_+$ matrices obtained from each sampling step.
```{r  function to compute means for posterior B0 and B+, echo=TRUE}
posteriorMeans = function(Bposteriors){
  Bposteriors.means = list(
  B0 = rowMeans(Bposteriors$B0.posterior, dims = 2),
  Bp = rowMeans(Bposteriors$Bp.posterior, dims = 2)
  )
}
```

The `pmatrix` function below prints the matrices in `R` in $\Latex$ form.
```{r  function to print matrix in latex format, echo=TRUE}
pmatrix <- function(x) {
  cat(c("$$\\begin{equation*}\n",
    "\\left(",
    knitr::kable(x, format = "latex", 
                 tabular = "array",
                 vline = "",
                 align = "c",
                 linesep = "",
                 toprule = NULL,
                 bottomrule = NULL),
    "\n\\right)\\, .\n",
    "\\end{equation*}$$\n"))
}
```

### Simulation Run
The purpose of this simulation run is to verify whether my model and corresponding code can replicate the true parameters of a data-generating process. To do this, I create artificial data containing 1000 observations simulated from a bi-variate Gaussian random walk process with the covariance matrix equal to the identity matrix of order 2. Then, I estimate a model with a constant term and 1 lag with the artificial data. And I show that the posterior mean of the autoregressive and the covariance matrices are close to an identity matrix and that the posterior mean of the constant term is close to a vector of zeros.

This process is laid out in steps below:

***Step 1:*** The following code generates artificial data containing 1000 observations from a bi-variate Gaussian random walk process with the covariance matrix equal to the identity matrix of order 2.
```{r  Step 1 - Generate artificial data, echo=TRUE}

set.seed(12345)

sim.p = 1
sim.T = 1000
sim.N = 2
sim.K = 1 + sim.N*sim.p

sim.Y           = arima.sim(list(order = c(0,1,0)), n = sim.T + sim.p-1, mean = 0, sd =1)
for (i in 2:sim.N){
  sim.Y         = rbind(sim.Y, arima.sim(list(order = c(0,1,0)), n = sim.T + sim.p-1, mean = 0, sd = 1))
}

sim.X           = matrix(1,1,sim.T)
for (i in 1:sim.p){
  sim.X         = rbind(sim.X, sim.Y[,(sim.p+1-i):(ncol(sim.Y)-i)])
}
sim.Y           = sim.Y[,-sim.p]
artificialdata  = list(p = sim.p, N = sim.N, K = sim.K, Y = sim.Y, X = sim.X)

```



***Step 2:*** We obtain a list of simulation priors and posteriors using the `prior` and `posterior` functions. 
```{r  Step 2 - Compute priors and posteriors for simulated data, echo=TRUE}
sim.priors      = prior(parameters, artificialdata)
sim.posteriors  = posterior(sim.priors, artificialdata)
```

***Step 3:*** We create a list of $V_n$ and $b_n$ corresponding to a lower triangular exclusion restriction on $B_0$ using the `ltexclusion` function.
```{r  Step 3 - Impose exclusion restriction on simulated data; get b_n and V_n, echo=TRUE}
sim.B0Vlist   = ltexclusion(artificialdata)
```

***Step 4:*** We sample the $B_0$ and $B_p$ posteriors with the Gibbs sampler using the `posteriorSimulations` function, and save the results for future use.
```{r  Step 4 - estimate and draw B0 and B+, save  simulated data, echo=TRUE, eval=FALSE }
sim.Bposteriors       = posteriorSimulations(parameters, sim.posteriors, sim.B0Vlist, artificialdata$N)
save(sim.Bposteriors, sim.priors, sim.posteriors, file = "sim-posteriors.RData")
```

```{r  Step 4b - load saved simulated posteriors, eval=TRUE}
load(file = "sim-posteriors.RData")
```

***Step 5:*** We compute the sample averages of our posterior $B_0$ and $B_+$. We use the `pmatrix` function to display the results as a matrix.
```{r  Step 5a - Compute the posterior means of B0 for simulated data, echo=TRUE, results='asis'}
sim.Bposteriors.means = posteriorMeans(sim.Bposteriors)
sim_B0 = pmatrix(sim.Bposteriors.means$B0)
```
We can see that the computed $B_0$ covariance matrix is numerically identical to an identity matrix.

```{r  Step 5b - Compute the posterior means of Bp for simulated data, echo=TRUE, results='asis'}
sim_Bp = pmatrix(sim.Bposteriors.means$Bp)
```
The first column of $B_+$ represents the posterior mean of the constant term. The values are small and close to zero.
The rest of the $B_+$ matrix represents the autoregressive matrix. Its posterior mean is numerically equal to an identity matrix.


### Data Results

***Step 1:*** I set the desired number of lags in the model and use the data to create matrices $X$ and $Y$. I store my data as a list named `mydata`.
```{r  Step 1 - set lags, create Y and X matrices, echo=TRUE}
# Y is N by T; X is K by T

p = 4                                   # set a number of lags included
N = ncol(df)
K = 1 + N*p

Y = t(df[(p+1):nrow(df),])
X = matrix(1,1,ncol(Y))

for (i in 1:p){
  X    = rbind(X,t(df[((p+1):nrow(df))-i,]))
}

mydata = list(p=p,N=N,K=K,Y=Y,X=X)
```

***Step 2:*** We obtain a list of data priors and posteriors using the `prior` and `posterior` functions.
```{r  Step 2 - Compute priors and posteriors, echo=TRUE}
priors     = prior(parameters, mydata)
posteriors = posterior(priors, mydata)
```

***Step 3:*** We create a list of $V_n$ and $b_n$ corresponding to a lower triangular exclusion restriction on $B_0$ using the `ltexclusion` function.
```{r  Step 3 - Impose exclusion restrictions, echo=TRUE}
B0Vlist       = ltexclusion(mydata)
```


***Step 4:*** We sample the $B_0$ and $B_p$ posteriors with the Gibbs sampler using the `posteriorSimulations` function, and save the results for future use.
```{r  Step 4 - Estimate and sample B0 and B+; save data, echo=TRUE,eval=FALSE}
Bposteriors           = posteriorSimulations(parameters, posteriors, B0Vlist, mydata$N)
save(Bposteriors, priors, posteriors, file = "data-posteriors.RData")
```


```{r  Step 4b - load saved data posteriors, eval=TRUE}
load(file = "data-posteriors.RData")
```

***Step 5:*** We compute the sample averages of our posterior $B_0$ and $B_+$. We use the `pmatrix` function to display the results as a matrix.
```{r  Step 5 - Compute posterior means for B0 and B+, echo=TRUE, results='asis'}
Bposterior.means = posteriorMeans(Bposteriors)
data_B0 = pmatrix(Bposterior.means$B0)
```

```{r  Step 5b - Compute the posterior means of Bp for actual data, echo=TRUE, results='asis'}
data_Bp = pmatrix(Bposterior.means$Bp)
```

## Extended Model
In the extended model, I will estimate the hyperparameters rather than setting them exogenously. Such estimation procedure often improves the fit of the model especially because the results can be sensitive to the parameterisation of the hyperparameters. 
In particular, I estimate $(\kappa_0, \kappa_+)$ such that $\underline S = \kappa_0 I_N$ and $\underline \Omega = \kappa_+ I_K$.

### Prior Distribution

I postulate the following prior distributions for the hyperparameters:
$$
\begin{align*}
    \kappa_0 | \underline s_{\kappa_0}, \underline \nu_{\kappa_0} \sim \mathcal{IG}2(\underline s_{\kappa_0}, \underline \nu_{\kappa_0})  && \kappa_+ | \underline s_{\kappa_+}, \underline \nu_{\kappa_+} \sim \mathcal{G}(2 \underline s_{\kappa_+}, \frac{1}{2} \underline \nu_{\kappa_+}) 
  \end{align*}
$$

The `ext.priors` function creates a list containing all the elements of the prior.
```{r  hyperparameter priors, echo=TRUE}
ext.priors = function(parameters,usedata){
  ext.prior = list(
  kappa0.s = .1,
  kappa0.nu = 1,
  kappap.s = .1,
  kappap.nu = 1,
  B       = cbind(rep(0,usedata$N), diag(usedata$N), matrix(0, usedata$N, (usedata$p-1)*usedata$N)), # random walk prior
  Omega   = parameters$kappa2 * diag(usedata$K),
  S       = parameters$kappa3*diag(usedata$N),
  nu      = usedata$N
)
}
```


Moreover, we have 
$$
  \begin{align*}
    p(B_{+n}|b_n, \kappa_+) = \mathcal{N}_k (b_n V_n B, \kappa_+ \Omega) && p(b_n| \kappa_0) = \mathcal{N}_{r_n}(0, \kappa_0 S)
  \end{align*}
$$

### Posterior Distribution

Thus, posteriors can be written as
$$
  \begin{align*}
    & p(\kappa_0 | Y, X, B_0) \propto p(B_0|\kappa_0) p(\kappa_0 | \underline s_{\kappa_0}, \underline \nu_{\kappa_0} )\\
    & \propto \prod_{n=1}^{N}\left(\kappa_0^{-\frac{1}{2}}\right)^{r_n} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N b_n V_n (\kappa_0 I_N)^{-1} V_n' b_n'  \right\} \cdot \kappa_0^{-\frac{\underline \nu_{\kappa_0}+2}{2}} \exp \left\{  -\frac{\underline s_{\kappa_0}}{2 \kappa_0} \right\}\\ 
    & \propto \kappa_0^{ -\frac{\underline \nu_{\kappa_0} + 2 + \sum_{n=1}^{N}r_n}{2}} \cdot \exp \left\{  -\frac{1}{2 \kappa_0} \sum_{n=1}^N b_n V_n V_n' b_n' + \underline s_{\kappa_0} \right\}\\
  \end{align*}
$$
  This gives
$$\bar s_{\kappa_0} =  \sum_{n=1}^N b_n V_n V_n' b_n' + \underline s_{\kappa_0}.$$
$$\bar \nu_{\kappa_0} = \underline \nu_{\kappa_0} +\sum_{n=1}^{N}r_n$$
  Also,
$$
  \begin{align*}
    & p(\kappa_+ | Y, X, B_+, B_0, \kappa_0) \propto p(B_+|\kappa_+, B_0, \kappa_0) p(\kappa_+ | \underline s_{\kappa_+}, \underline \nu_{\kappa_+} )\\
    & \propto \kappa_+^{-\frac{KN}{2}} \exp \left\{  -\frac{1}{2} \sum_{n=1}^N (B_{+n} - b_n V_n \underline B) (\kappa_+ I_{K})^{-1} (B_{+n} - b_n V_n \underline B)'  \right\} \cdot \kappa_+^{-\frac{\underline \nu_{\kappa_+} + 2}{2}} \exp \left\{  -\frac{ \kappa_+}{2 \underline s_{\kappa_+}} \right\}\\
    & = \kappa_+^{-\frac{\underline \nu_{\kappa_+} + KN}{2} - 1} \cdot \exp \left\{  -\frac{1}{2} \left( (B_{+n} - b_n V_n \underline B)  (B_{+n} - b_n V_n \underline B)' \cdot \frac{1}{\kappa_+} + \frac{1}{\underline s_{\kappa_+}} \kappa_+  \right) \right\}\\
  \end{align*}
$$
  This gives
$$\lambda = -\frac{\underline \nu_{\kappa_+} + KN}{2}$$
$$\chi =  \sum_{n=1}^N  (B_{+n} - b_n V_n \underline B)  (B_{+n} - b_n V_n \underline B)'$$
$$\Psi = \frac{1}{\underline s_{\kappa_+}}$$
  
  
The `init.struct` function creates and initialise a list that contains matrices to store draws of $\{\kappa_0^{(s)}, \kappa_+^{(s)}, B_0^{(s)}, B_+^{(s)}\}_{s =1}^{S}$.
```{r  Structures, echo=TRUE}
  init.struct = function(usedata,S){
    kappa0 = array(NA,c(1,S))
    kappa0[1] = 10
    kappap = rep(NA, S)
    kappap[1] = 10
    B0.post = array(NA, c(usedata$N,usedata$N,S))
    Bp.post = array(NA, c(usedata$N,usedata$K,S))
    list(kappa0 = kappa0, kappap = kappap, B0.post = B0.post, Bp.post = Bp.post)
  }
```

### (Gibbs) Sampling

The sampling function `ext.sampling` is given below. The sampling procedure is as 
```{r  Sampling, echo=TRUE}
ext.sampling = function(parameters, struct, priors, usedata){
  set.seed(12345)
  B0Vlist.initial = ltexclusion(usedata)
  B0.initial = B0Vlist.initial$B0
  for (i in 1:(parameters$S + parameters$S.burnin)){
    
    # Computing posterior parameters for each draw
    Omega.inv      = solve(struct$kappap[i] * priors$Omega)
    Omega.post.inv = usedata$X%*%t(usedata$X) + Omega.inv
    Omega.post     = solve(Omega.post.inv)
    B.post         = (usedata$Y%*%t(usedata$X) + priors$B%*%Omega.inv) %*% Omega.post
    S.post         = solve(usedata$Y%*%t(usedata$Y) + solve(struct$kappa0[i] * priors$S) + priors$B%*%Omega.inv%*%t(priors$B) - B.post%*%Omega.post.inv%*%t(B.post) )
    nu.post        = ncol(usedata$Y) + priors$nu


  if (i > 1){
    B0.initial = struct$B0.post[,,i-1]
  }
  
  B0.i = rgn(n=1, S.inv = solve(S.post), nu = nu.post, V = B0Vlist.initial$V, B0.initial = B0.initial)
  B0.hat = t(chol((nu.post - usedata$N)*S.post))
  B0.norm.i = normalize.Gibbs.output.parallel(B0.i, B0.hat)
  Bp.i = rnorm.ngn(B0.norm.i, B.post, Omega.post)
  
  struct$B0.post[,,i] = B0.norm.i
  struct$Bp.post[,,i] = Bp.i
  
  # Now, update kappa
  kappa0.nu.post = priors$kappa0.nu + (usedata$N/2)
  kappap.lambda.post = -(priors$kappap.nu + usedata$K * usedata$N)/2
  kappap.psi.post = 1/priors$kappap.s
  kappa0.s.post = priors$kappa0.s
  # kappap.chi.post = 0
  for (n in 1:usedata$N){
    # kappa0.s.post = kappa0.s.post + B0.norm.i[n,,1] %*% t( B0.norm.i[n,,1])
    kappa0.s.post = kappa0.s.post + sum(B0.norm.i[n,,1]^2)
    kappap.chi.post = (Bp.i[n,,1] - B0.norm.i[n,,1] %*% B.post) %*% t(Bp.i[n,,1] - B0.norm.i[n,,1] %*% B.post)
  }
  
  if (i != (parameters$S + parameters$S.burnin)){
    struct$kappa0[i+1] = kappa0.s.post / rchisq(n=1,df = kappa0.nu.post)
    struct$kappap[i+1] = GIGrvg::rgig(n=1, kappap.lambda.post, kappap.chi.post, kappap.psi.post)
  }
  }
  struct$kappa0 = struct$kappa0[(parameters$S.burnin+1):(parameters$S.burnin + parameters$S)]
  struct$kappap = struct$kappap[(parameters$S.burnin+1):(parameters$S.burnin + parameters$S)]
  struct$B0.post = struct$B0.post[,,(parameters$S.burnin+1):(parameters$S.burnin + parameters$S)]
  struct$Bp.post = struct$Bp.post[,,(parameters$S.burnin+1):(parameters$S.burnin + parameters$S)]
  return(struct)
  
}

```

```{r  function to compute struct posterior means, echo=TRUE}
structPosteriorMeans = function(struct){
  struct.means = list(
  kappa0 = mean(struct$kappa0),
  kappap = mean(struct$kappap),
  B0 = rowMeans(struct$B0.post, dims = 2),
  Bp = rowMeans(struct$Bp.post, dims = 2)
  )
}
```

### Simluation Run

***Step 1:*** The following code computes the prior, initialises matrices to store results, and samples the draws for the simulated data.
```{r  Running extension for simulated data, echo=TRUE, eval = FALSE}
ext.sim.prior = ext.priors(parameters, artificialdata)
ext.sim.struct = init.struct(artificialdata, parameters$S + parameters$S.burnin)
ext.sim.struct <- ext.sampling(parameters, ext.sim.struct, ext.sim.prior, artificialdata)
```

```{r  save simulation struct, eval=FALSE}
save(ext.sim.struct, file = "ext.sim.struct.RData")
```

```{r  load simulation struct, eval=TRUE}
load(file = "ext.sim.struct.RData")
```

***Step 2:*** The following code computes and stores the posterior means of $\{\kappa_0^{(s)}, \kappa_+^{(s)}, B_0^{(s)}, B_+^{(s)}\}_{s =1}^{S}$.
```{r  compute the simulated struct posterior means for the data, echo=TRUE}
ext.sim.struct.means = structPosteriorMeans(ext.sim.struct)
```

***Step 3:*** The code snippets below display the sample posterior means of the estimated objects using simulated data.

The following code computes the posterior mean of $B_0$.
```{r  display in latex mode the simulated posterior means of B_0, results='asis', echo=TRUE}
ext.sim.data_B0 = pmatrix(ext.sim.struct.means$B0)
```

The following code computes the posterior mean of $B_+$.
```{r display sample average B_+, results='asis', echo=TRUE}
ext.sim.data_Bp = pmatrix(ext.sim.struct.means$Bp)

```

The following code computes the posterior mean of $\kappa_0$.
```{r display sample average draw of kappa_0, results='asis', echo=TRUE}
ext.sim.data_kappa0 = pmatrix(ext.sim.struct.means$kappa0)
```

The following code computes the posterior mean of $\kappa_+$.
```{r display sample average draw of kappa_+, results='asis', echo=TRUE}
ext.sim.data_kappap = pmatrix(ext.sim.struct.means$kappap)

```

### Data Results

***Step 1:*** The following code computes the prior, initialises matrices to store results, and samples the draws for the actual data.
```{r  Running extension for actual data, eval = FALSE, include=TRUE}
ext.prior = ext.priors(parameters, mydata)
ext.struct = init.struct(mydata, parameters$S + parameters$S.burnin)
ext.struct <- ext.sampling(parameters, ext.struct, ext.prior, mydata)
```

```{r  save struct for extension model, eval=FALSE}
save(ext.struct, file = "ext.struct.RData")
```

```{r  load struct for extension model, eval=TRUE}
load(file = "ext.struct.RData")
```



***Step 2:*** The following code computes and stores the posterior means of $\{\kappa_0^{(s)}, \kappa_+^{(s)}, B_0^{(s)}, B_+^{(s)}\}_{s =1}^{S}$.
```{r  compute the struct posterior means for the data, echo=TRUE}
ext.struct.means = structPosteriorMeans(ext.struct)
```

***Step 3:*** The code snippets below display the sample posterior means of the estimated objects using actual data.

```{r  display in latex mode the posterior means matrices, results='asis', echo=TRUE}
ext.data_B0 = pmatrix(ext.struct.means$B0)

```

```{r display the extension model posterior mean of B_0, results='asis', echo=TRUE}
ext.data_Bp = pmatrix(ext.struct.means$Bp)
```

```{r display the extension model posterior mean of kappa_0, results='asis', echo=TRUE}
ext.data_kappa0 = pmatrix(ext.struct.means$kappa0)
```

```{r display the extension model posterior mean of kappa_+, results='asis', echo=TRUE}
ext.data_kappap = pmatrix(ext.struct.means$kappap)
```

# Empirical Investigation

## Impulse Response Functions (IRFs)
```{r  function to compute the irf and fevd matrices, echo=TRUE}
irf_fevd = function(parameters, usedata, Bposteriors){
  # Unpack variables
  N = usedata$N
  K = usedata$K
  p = usedata$p
  S = parameters$S
  h = parameters$h
  B0.posterior = Bposteriors$B0.posterior
  Bp.posterior = Bposteriors$Bp.posterior
  
  B.posterior       = array(NA,c(N,N,S))
A.posterior       = array(NA,c(N,K,S))
for (s in 1:S){
  B               = solve(B0.posterior[,,s])
  B.posterior[,,s]= B
  A.posterior[,,s]= B %*% Bp.posterior[,,s]
}

IRF.posterior     = array(NA,c(N,N,h+1,S))
IRF.inf.posterior = array(NA,c(N,N,S))
FEVD.posterior    = array(NA,c(N,N,h+1,S))
J                 = cbind(diag(N),matrix(0,N,N*(p-1)))
for (s in 1:S){
  A.bold          = rbind(A.posterior[,2:(1+N*p),s],cbind(diag(N*(p-1)),matrix(0,N*(p-1),N)))
  IRF.inf.posterior[,,s]          = J %*% solve(diag(N*p)-A.bold) %*% t(J) %*% B.posterior[,,s]
  A.bold.power    = A.bold
  for (i in 1:(h+1)){
    if (i==1){
      IRF.posterior[,,i,s]        = B.posterior[,,s]
    } else {
      IRF.posterior[,,i,s]        = J %*% A.bold.power %*% t(J) %*% B.posterior[,,s]
      A.bold.power                = A.bold.power %*% A.bold
    }
    for (n in 1:N){
      for (nn in 1:N){
        FEVD.posterior[n,nn,i,s]  = sum(IRF.posterior[n,nn,1:i,s]^2)
      }
    }
    FEVD.posterior[,,i,s]         = diag(1/apply(FEVD.posterior[,,i,s],1,sum))%*%FEVD.posterior[,,i,s]
  }
}
FEVD.posterior    = 100*FEVD.posterior

list(IRF.posterior = IRF.posterior, IRF.inf.posterior= IRF.inf.posterior, FEVD.posterior = FEVD.posterior)
}
```

```{r compute the irf and fevd results for data, eval=FALSE}
data.irf_fevd = irf_fevd(parameters, mydata, Bposteriors)
```

```{r save the irf and fevd results for data, eval=FALSE}
save(data.irf_fevd, file = "data.irf_fevd.RData")
```

```{r load the irf and fevd results for data, eval=TRUE}
load("data.irf_fevd.RData")
```


```{r  function that plots the irf of chosen variable position}
plot_irf = function(position, fevd, parameters){
  # Unpack results
IRF.posterior = fevd$IRF.posterior

IRF.posterior.mps = IRF.posterior[,position,,]
IRFs.k1           = apply(IRF.posterior.mps,1:2,median)
IRF.posterior.mps = IRF.posterior.mps*(0.25/IRFs.k1[position,1])
IRFs.k1           = apply(IRF.posterior.mps,1:2,median)
IRFs.inf.k1       = apply(IRF.posterior.mps,1,mean)
var_names         = colnames(df)
rownames(IRFs.k1) = var_names

IRFs.k1.hdi       = apply(IRF.posterior.mps,1:2, hdi, credMass=0.68)
h                 = parameters$h
hh                = 1:(h+1)

# Define colours
mcxs1  = "#05386B"
mcxs2  = "#379683"
mcxs3  = "#5CDB95"
mcxs4  = "#8EE4AF"
mcxs5  = "#EDF5E1"
purple = "#b02442"

mcxs1.rgb   = col2rgb(mcxs1)
mcxs1.shade1= rgb(mcxs1.rgb[1],mcxs1.rgb[2],mcxs1.rgb[3], alpha=120, maxColorValue=255)
mcxs2.rgb   = col2rgb(mcxs2)
mcxs2.shade1= rgb(mcxs2.rgb[1],mcxs2.rgb[2],mcxs2.rgb[3], alpha=120, maxColorValue=255)

# Save as pdf
par(mfrow=c(3,3), mar=c(2,2,2,2))
for (n in 1:N){
  ylims     = range(IRFs.k1[n,hh],IRFs.k1.hdi[,n,1:4],0)
  p1 <- plot(hh,IRFs.k1[n,hh], type="l", ylim=ylims, axes=FALSE, xlab="", main=rownames(IRFs.k1)[n])

  axis(1,c(1,2,5,7,9,13,17),c("","1 quarter","1 year","6 quarters", "2 years", "3 years", "4 years"))
  
  axis(2,c(ylims[1],0,ylims[2]),round(c(ylims[1],0,ylims[2]),3))
  polygon(c(hh,(h+1):1), c(IRFs.k1.hdi[1,n,hh],IRFs.k1.hdi[2,n,(h+1):1]), col=mcxs1.shade1,border=mcxs1.shade1)
  abline(h=0)
  lines(hh, IRFs.k1[n,hh],lwd=2,col=mcxs1)
}
return(list(p1))
}
```

```{r irf of cashrate}
#| label: cashrate.irf
#| fig-cap: "IRF plots for the AU Cash Rate Shock"
#| fig-cap-location: top
cashrate.irf = plot_irf(5, data.irf_fevd, parameters)
```

```{r irf of usffr}
#| label: usffr.irf
#| fig-cap: "IRF plots for the US Federal Funds Rate Shock"
#| fig-cap-location: top
usffr.irf = plot_irf(1, data.irf_fevd, parameters)
```

```{r save the irf figures as pdf, eval=FALSE}
pdf(file = "aucr_irf.pdf", onefile = FALSE, width = 16, height = 9)
plot_irf(8, data.irf_fevd, parameters)
dev.off()

pdf(file = "usffr_irf.pdf", onefile = FALSE, width = 16, height = 9)
plot_irf(4, data.irf_fevd, parameters)
dev.off()
```


## Forecast Error Variance Decomposition

```{r function to plot the fevd of variables given position}
plot_fevd = function(position, fevd, parameters){
  FEVD.posterior = fevd$FEVD.posterior
  h = parameters$h
  N = dim(FEVD.posterior)[1]
  ffr.pos = which(colnames(df) == "US FFR Max Target Rate")
  cr.pos = which(colnames(df) == "RBA Target Cash Rate")
  
  hh            = 1:(h+1)
fevd.mat  = apply(FEVD.posterior[position,,,],1:2,mean)
fevd.mat  = rbind(rep(0,h+1),apply(fevd.mat,2,cumsum))

colors = c("deepskyblue1","deepskyblue2","deepskyblue","deepskyblue3","deepskyblue4","dodgerblue",
           "maroon1","maroon","maroon2","magenta","maroon3","maroon4")

par(mar=rep(4,4),cex.axis=1, cex.lab=0.8)
p1 <- plot(hh,fevd.mat[1,], type="n", ylim=c(0,100), axes=FALSE, xlab="", ylab="")
axis(1,c(1,2,5,7,9,13,17),c("","1 quarter","1 year","6 quarters", "2 years", "3 years", "4 years"))
axis(2,c(0,50,100),c("",colnames(df)[position],""))
for (n in 1:N){
  polygon(c(hh,(h+1):1), c(fevd.mat[n,hh],fevd.mat[n+1,(h+1):1]), col=colors[n],border=colors[n])
}
axis(4, (0.5*(fevd.mat[(1:N),(h+1)]+fevd.mat[2:(N+1),(h+1)]))[c(ffr.pos,position,cr.pos)], c("us.mps","","au.mps")) # fix position of terms

return(list(p1))
}
```

```{r fevd for nominal gdp}
variable.choice = "Nominal GDP (log)"
position = which(colnames(df) == variable.choice)
gdp.fevd = plot_fevd(position, data.irf_fevd, parameters)
```

```{r fevd for consumption}
variable.choice = "Aggregate Consumption (log)"
position = which(colnames(df) == variable.choice)
con.fevd = plot_fevd(position, data.irf_fevd, parameters)
```

```{r fevd for change in cpi}
variable.choice = "% Change in CPI, yoy"
position = which(colnames(df) == variable.choice)
cpi.fevd = plot_fevd(position, data.irf_fevd, parameters)
```

```{r fevd for usffr}
variable.choice = "US FFR Max Target Rate"
position = which(colnames(df) == variable.choice)
usffr.fevd = plot_fevd(position, data.irf_fevd, parameters)
```

```{r fevd for quantity of new homes}
variable.choice = "Quantity of new homes (log)"
position = which(colnames(df) == variable.choice)
nh.fevd = plot_fevd(position, data.irf_fevd, parameters)
```

```{r fevd for house price index}
variable.choice = "House Price Index (log)"
position = which(colnames(df) == variable.choice)
hpi.fevd = plot_fevd(position, data.irf_fevd, parameters)
```

```{r fevd for homeloan rates, warning=FALSE}
variable.choice = "Owner-occupied home loan rates"
position = which(colnames(df) == variable.choice)
hlr.fevd = plot_fevd(position, data.irf_fevd, parameters)
```

```{r fevd for cashrate, warning=FALSE}
variable.choice = "RBA Target Cash Rate"
position = which(colnames(df) == variable.choice)
aucr.fevd = plot_fevd(position, data.irf_fevd, parameters)
```


```{r fevd for m1}
variable.choice = "M1 Money Supply (logs)"
position = which(colnames(df) == variable.choice)
m1.fevd = plot_fevd(position, data.irf_fevd, parameters)
```


```{r save fevd figures in a single plot, eval=FALSE}
fevd.plots = c("gdp.fevd", "con.fevd", "cpi.fevd", "usffr.fevd", "nh.fevd", "hpi.fevd", "hlr.fevd", "aucr.fevd", "m1.fevd")
  # Save each plot as an EPS file
  for (i in 1:length(fevd.plots)) {
    filename <- paste0(fevd.plots[i], ".pdf")
    pdf(file = filename, onefile = FALSE, height=9, width = 16)
    plot_fevd(i, data.irf_fevd, parameters)
    dev.off()
  }

```



# Appendix {#appendix}
```{r, file="L16 codes.R"}
```


# References {.unnumbered}



